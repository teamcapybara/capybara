require 'webrick'
require 'webrick/httpproxy'
require 'webrick/https'
require 'rack/test'

module Capybara
  class ProxyServer < WEBrick::HTTPProxyServer

    class SSLHandler < WEBrick::HTTPServer
      def initialize(app, config)
        super(config.merge(:Port => 443, :DoNotListen => true))
        @rack_handler = Rack::Handler::WEBrick.new(self, app)
      end

      def service(req, res)
        if (host_handler = Capybara::ProxyServer.host_mapping[req.host])
          Rack::Handler::WEBrick.new(self, host_handler).service(req, res)
        else
          @rack_handler.service(req, res)
        end
      rescue => err
        $stderr.puts err
      end
    end

    DEFAULT_404_HANDLER = Proc.new {|env| [404, {}, []] }

    class << self
      attr_accessor :host_mapping

      ##
      #
      # Configure Capybara ProxyServer to suit your needs.
      #
      #     Capybara::ProxyServer.configure do |config|
      #       config.route "i.kissmetrics.com" => Capybara::ProxyServer::DEFAULT_404_HANDLER
      #     end
      #
      def configure
        yield self
      end

      ##
      #
      # Route a request to a specific host to a separate Rack application.
      # This allows you to mock external services without actually doing external requests.
      #
      # You can use the Capybara::ProxyServer::DEFAULT_404_HANDLER to simply return a 404 error code, or create your own rack applications.
      #
      def route(host_map)
        @host_mapping ||= {}
        @host_mapping.merge!(host_map)
      end

      def run(app, config)
        server = new(app, config.merge(:OutputBufferSize => 5))
        server.start
        server
      end
    end

    def initialize(app, config)
      super(config, WEBrick::Config::HTTP)
      @rack_handler = Rack::Handler::WEBrick.new(self, app)
      @ssl_context = generate_ssl_context
      @ssl_server = SSLHandler.new(app, config)
    end

    def service(req, res)
      if req.request_method == "CONNECT"
        host, port = req.unparsed_uri.split(":", 2)
        if port == '443'
          ua = Thread.current[:WEBrickSocket]
          res.status = WEBrick::HTTPStatus::RC_OK
          res.send_response(ua)
          req.parse(NullReader) rescue nil
          ssl = OpenSSL::SSL::SSLSocket.new(ua, @ssl_context)
          ssl.sync_close = true
          ssl.accept
          @ssl_server.run(ssl)
        else
          res.status = 501
        end
      elsif (host_handler = Capybara::ProxyServer.host_mapping[req.host])
        Rack::Handler::WEBrick.new(self, host_handler).service(req, res)
      else
        @rack_handler.service(req, res)
      end
    rescue => err
      $stderr.puts err
    end

    private

    def generate_ssl_context
      OpenSSL::SSL::SSLContext.new(:TLSv1_server).tap do |ssl_context|
        self_signed_cert, self_signed_cert_key =
          WEBrick::Utils.create_self_signed_cert(1024, [ [ "CN", "localhost" ] ], "Generated by Ruby/OpenSSL")
        ssl_context.cert = self_signed_cert
        ssl_context.key = self_signed_cert_key
      end
    end
  end
end

Capybara::ProxyServer.configure do |config|
  config.route "www.google-analytics.com" => Capybara::ProxyServer::DEFAULT_404_HANDLER,
    "ssl.google-analytics.com" => Capybara::ProxyServer::DEFAULT_404_HANDLER,
    "fonts.googleapis.com" => Capybara::ProxyServer::DEFAULT_404_HANDLER,
    "connect.facebook.net" => Capybara::ProxyServer::DEFAULT_404_HANDLER,
    "platform.twitter.com" => Capybara::ProxyServer::DEFAULT_404_HANDLER
end
